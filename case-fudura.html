<!DOCTYPE html>
<html lang="en" class="no-js">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Stephan van Stekelenburg</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="Stephan van Stekelenburg" />
  <meta name="keywords" content="fudura, azure, iot, distributed systems, case study, service fabric" />
  <meta name="author" content="Stephan van Stekelenburg" />
  <link rel="shortcut icon" href="favicon.ico">

  <link rel="stylesheet" href="css/bootstrap.css" type="text/css">
  <link rel="stylesheet" href="css/normalize.css" type="text/css">
  <link rel="stylesheet" href="css/animate.css" type="text/css">
  <link rel="stylesheet" href="css/transition-animations.css" type="text/css">
  <link rel="stylesheet" href="css/owl.carousel.css" type="text/css">
  <link rel="stylesheet" href="css/magnific-popup.css" type="text/css">
  <link rel="stylesheet" href="css/main.css" type="text/css">

  <script src="js/jquery-2.1.3.min.js"></script>
  <script src="js/modernizr.custom.js"></script>
</head>

<body class="material-template">
  <!-- Loading animation -->
  <div class="preloader">
    <div class="preloader-animation">
      <div class="preloader-spinner">
      </div>
    </div>
  </div>
  <!-- /Loading animation -->

  <div id="page" class="page">
    <!-- Header -->
    <header id="site_header" class="header mobile-menu-hide">
      <div class="header-content">
        <div class="site-title-block mobile-hidden">
          <div class="site-title">Stephan
            <span>van Stekelenburg</span>
          </div>
        </div>

        <div class="site-nav">
          <ul id="nav" class="site-main-menu">
            <li>
              <a class="pt-trigger" href="index.html#home" data-animation="62">Home</a>
              <!-- href value = data-id without # of .pt-page. -->
            </li>
            <li>
              <a class="pt-trigger" href="index.html#resume" data-animation="62">Resume</a>
            </li>
            <li>
              <a class="pt-trigger" href="index.html#services" data-animation="62">Services</a>
            </li>
            <li>
              <a class="pt-trigger" href="index.html#cases" data-animation="62">Cases</a>
            </li>
            <li>
              <a class="pt-trigger" href="index.html#contact" data-animation="62">Contact</a>
            </li>
          </ul>
        </div>
      </div>
    </header>
    <!-- /Header -->

    <!-- Mobile Header -->
    <div class="mobile-header mobile-visible">
      <div class="mobile-logo-container">
        <div class="mobile-site-title">Stephan van Stekelenburg</div>
      </div>

      <a class="menu-toggle mobile-visible">
        <i class="fa fa-bars"></i>
      </a>
    </div>
    <!-- /Mobile Header -->

    <!-- Main Content -->
    <div id="main" class="site-main">
      <!-- Single Page Content -->
      <div class="single-page-content">
        <div class="content-area">
          <div class="page-content">
            <!-- Blog Entry Content -->
            <div class="blog-post-main-image">
              <img class="post-image img-responsive" src="images/cases/case_fudura_full.jpg" alt="Fudura" />
            </div>

            <div class="blog-post-content">
              <h1>Scalable MaaS Platform for Fudura</h1>

              <div class="entry-meta">
                <span class="date">
                  <a>
                    <i class="fa fa-fw fa-clock-o"></i> August, 2017</a>
                </span>
                <span class="divider">|</span>
                <span class="autor">
                  <a>
                    <i class="fa fa-fw fa-user"></i> Stephan van Stekelenburg</a>
                </span>
                <span class="divider">|</span>
                <span class="category">
                  <a>
                    <i class="fa fa-fw fa-folder"></i> Case Study</a>
                </span>
              </div>

              <p>
                Fudura provides metering services that help make energy flows visible and manageable. They measure and analyze energy consumption;
                give advice on energy infrastructure and savings; rent technical equipment; and design, manage, and maintain
                energy supply systems.
              </p>

              <p>
                Stephan helped Fudura make a transition to a smart metering solution with a microservices-based architecture built on Service
                Fabric and deployed in the Azure cloud.
              </p>

              <blockquote>
                <p>
                  "Service Fabric is key in our mission to deliver scalable and affordable services. By leveraging the many features of Service
                  Fabric, the software team can focus on creating business value."
                </p>
                <footer>
                  <cite>Peter Meulmeester, Fudura Senior Business Developer</cite>
                </footer>
              </blockquote>

              <h2>Making energy flows visible and manageable</h2>

              <p>
                Fudura operates a heterogeneous pool of connected field devices, such as gas and electricity meters, each emitting valuable
                data. This telemetry was being sent to a legacy platform mainly consisting of large software packages deployed
                on premises. But that platform was no longer flexible or cost effective enough to meet new customer demands.
                Fudura needed to speed up time-to-market, provide competitive pricing, and quickly innovate in an ever-changing
                energy market.
              </p>

              <p>
                A new architecture based on microservices provided the solution. MaaS allows Fudura to collect, validate, and distribute
                telemetry originating from various connected devices. The MaaS platform takes care of provisioning and monitoring
                these devices. Collected telemetry can be routed to standard customer portals. When customers want more options,
                the Fudura team can quickly build specialized business scenarios and deploy them flexibly as separate microservices.
                By providing an easy way to interact with a large set of supported devices, MaaS gave Fudura the flexibility
                they needed to empower customers to take control of their energy flows.
              </p>

              <blockquote>
                <p>
                  "By automating device connectivity, provisioning, and monitoring at a large scale, Fudura is able to provide customers insight
                  into their energy flows at a very competitive price point."
                </p>
                <footer>
                  <cite>Jaap Mintjes, Fudura Project Manager</cite>
                </footer>
              </blockquote>

              <h2>Building a scalable MaaS platform</h2>

              <p>The MaaS platform consists of three main parts:</p>

              <dl>
                <dt>Protocol Gateway</dt>
                <dd>
                  This Service Fabric application connects to devices using various metering protocols such as device language message specification
                  (DLMS). For each physical device, a corresponding device agent starts and handles all communication with
                  the device. Collected telemetry is sent to Azure IoT Hub for further processing. Multiple instances of
                  the Protocol Gateway are deployed in different virtual networks to support connections with devices from
                  various partners and customers, typically through a virtual private network (VPN).
                </dd>

                <dt>Device Hub</dt>
                <dd>
                  This Service Fabric application provides core services such as a device registry for storing device configuration, a device
                  controller for starting and stopping device agents, and services for transforming incoming telemetry into
                  materialized views. To manage and monitor devices, Fudura and its customers use Control Center, a business-critical
                  component of Device Hub built using ASP.NET Core and Angular.
                </dd>

                <dt>Tailor-made business scenarios</dt>
                <dd>
                  If a customer requires software components not offered by the MaaS platform, Fudura can meet the need easily. For example,
                  a microservice can be created to aggregate telemetry into a customer-specific monthly report and deliver
                  it to the customer's FTP server.
                </dd>
              </dl>

              <p>
                All telemetry collected by the Protocol Gateways is published on an IoT Hub, including device readings and metadata events
                such as device health information. From the IoT Hub, an event can follow four major flows:
              </p>

              <ul>
                <li>
                  All events are processed by the Device Hub application. Several of its services, including Device Status, generate views
                  from the incoming events. Control Center can then display these views of the latest readings and health
                  information to users.
                </li>
                <li>
                  IoT Hub message routing dispatches events to the appropriate business scenarios. Events that match a filter are forwarded
                  to a scenario-specific Event Hub, and then can be ingested by the business scenario.
                </li>
                <li>
                  When further event processing is required for a business scenario, Azure Stream Analytics provides efficient windowing, geospatial
                  operations, and filtering.
                </li>
                <li>
                  Each event is archived in a deep storage store using Azure Blob storage. To support the growing archive, Azure Data Lake
                  Store will likely replace the Blob storage implementation in the near future.
                </li>
              </ul>

              <h2>Delivering a great user experience</h2>

              <p>
                To make sure the MaaS platform delivered great performance, the architecture was designed to keep frequently accessed (hot
                state) data close to the compute layer. Service Fabric stateful services offered very low-latency data access
                while enabling high reliability and availability. The Device Status stateful service stores its views in
                Service Fabric Reliable Collections for fast loading times when they are requested through the Control Center
                front end.
              </p>

              <p>
                Initially the development team used the Reliable Actors programming model to process the events and store the views. However,
                this design did not consider that in the single-threaded model, read requests from Control Center would end
                up queued behind write requests. In the actor model, an actor handles only one request at a time, an important
                benefit when updating the views in the actor, but not very good for querying those views. View retrieval
                was quick--but only when no updates were queued.
              </p>

              <p>
                To remove the dependency on a single threaded model, the implementation was changed to use Reliable Dictionaries to store
                the views instead of Reliable Actors. The service can now handle queries while simultaneously updating the
                views, which allows Control Center to be consistent while delivering great performance.
              </p>

              <p>
                The Device Status service stores the status state of all the devices in the platform, including their health state and latest
                readings. The development team is currently investigating the Azure Time Series Insights service, now in
                public preview, as an alternative for storing the collected readings.
              </p>

              <h2>Process managers and notifications using the actor model</h2>

              <p>
                In Control Center, Fudura manages device operations such as starting and stopping device agents. Control Center uses the
                Device Controller service to send a command to the correct Protocol Gateway over HTTP. The Protocol Gateway
                then executes the requested command.
              </p>

              <p>
                As the platform evolves, support for more complex scenarios is required. The team is developing a Device Management service
                containing process managers that coordinate processes consisting of multiple commands. The service also monitors
                progress. For example, the process for provisioning a new device consists of the following steps:
              </p>

              <ol>
                <li>Send a
                  <code>RegisterDevice</code> command to the Device Registry service to save the device configuration.</li>
                <li>Wait for the
                  <code>DeviceRegistered</code> event to occur. This event is raised by the Device Registry service after the configuration has been successfully
                  saved.</li>
                <li>Send a
                  <code>StartDeviceAgent</code> command to the Device Controller service.</li>
                <li>Wait for the
                  <code>DeviceAgentStarted</code> event to occur, which signals that the device agent has successfully started and will begin collecting
                  telemetry.</li>
              </ol>

              <p>The steps above represent the ideal flow. In production, though, various things can go wrong, so the process
                managers are designed to retry commands if the correct events are not received in the allotted time.</p>

              <p>The Reliable Actors programming model is a great fit for the Device Management service, because process managers
                are autonomous units of work that can be performed in parallel with each other. Each process manager is modeled
                as a single actor type.</p>

              <p>When starting a process, a new instance of the corresponding actor type is created. Each process manager actor
                instance is assigned a random actor ID. The actor ID is used for correlation; it is piggy-backed onto commands
                and events so that incoming events can be routed to the process manager actors that are waiting for them.</p>

              <p>Process managers can take some time to complete depending on the type of process. The caller that starts the
                process manager should not be blocked until the process manager has completed. To solve this issue, a reminder
                is scheduled to fire immediately when the process manager is called. The real work is done in a new call
                context when the reminder has fired, allowing the original caller to continue doing other work.</p>

              <p>To report progress, the process managers call the Notification service, also built using the Reliable Actors
                programming model. It contains two types of actors: the UserActor receives notifications targeted for a specific
                user, while the TenantActor receives notifications targeted to all users of a specific tenant.</p>

              <p>Actor events are used for these notifications. Actor events provide a way to send best-effort notifications
                from an actor to clients. Clients start listening for these events as soon as a user logs into Control Center.
                Each received actor event is forwarded to a SignalR Hub that forwards the notification to the user's Control
                Center instance running in a browser, where it is displayed.</p>

              <h2>Releasing and testing on Azure</h2>

              <p>At peak times, a team of 10 developers work on the MaaS platform. To work together efficiently, a comprehensive
                build-and-release pipeline was configured using the Visual Studio Team Services infrastructure. This pipeline
                uses four environments: local development, testing, acceptance, and production.</p>

              <p>Developers use the Service Fabric local development cluster to test and debug new MaaS platform features. Local
                development clusters run the same code as the production environment (no emulators are involved). Developers
                can be certain that the tested code can be deployed to other environments.</p>

              <p>To run integration tests with physical devices, developers can provision a test environment on demand based
                on the Git feature or release branch they are working on. Unlike a local development environment, no firewall
                or NAT routing constraints prevent testing, and there is no limit to the number of on-demand environments
                that developers can run consecutively.</p>

              <p>Developers use Azure Resource Manager templates to automatically provision a Service Fabric cluster as well
                as all other dependencies, which can include Application Insights, IoT Hubs, storage accounts, and Stream
                Analytics pipelines. After a cluster is provisioned and the software is deployed, integration tests can be
                run. To reduce costs, an on-demand environment is deployed as a single node test cluster. By changing a variable
                in the release pipeline, it can be provisioned as a multi-node cluster, a useful technique when testing failover
                and other scenarios.</p>

              <p>In test environments, Service Fabric application upgrades are disabled by default. When releasing a new version
                of the MaaS platform to the test environment, the application is removed and redeployed, leaving no state
                behind. This approach supports faster test cycles when the team is actively working on a new feature.</p>

              <p>The acceptance environment runs continuously and connects to a representative set of testing devices. On each
                deployment, developers use Resource Manager scripts to set up the environment even though it runs continuously.
                Resource Manager scripts are idempotent, meaning a template can be deployed repeatedly without breaking anything.
                When developers make supported changes to a template, the acceptance environment is upgraded accordingly.</p>

              <p>When a release has passed all required tests in an on-demand environment, it is deployed to the acceptance
                environment. Almost identical to the production environment, the acceptance environment is used to test the
                application upgrade process. After an upgrade is deployed successfully, final tests are run and, when approved,
                the new features move into the production environment.</p>

              <h2>Summary</h2>

              <p>When Fudura needed a more flexible, cost-effective platform for collecting and distributing device telemetry,
                MaaS was the answer. Stephan helped Fudura to make the transition, using Service Fabric to build a microservices-based
                architecture deployed in the Azure cloud.</p>

              <p>Service Fabric greatly reduced the complexity of building a distributed application. It handles reliability,
                scalability, and high availability, so the software team can focus on creating business value, thereby shortening
                the time to market. The deployment of on-demand test environments is automated using Resource Manager templates,
                and multiple features can be tested at the same time with real devices connected to the Azure cloud.</p>

              <p>With the new MaaS Platform Fudura can provide customers detailed insight into their energy flows at a very
                competitive price point.</p>

              <div class="entry-meta entry-tags-share">

                <div class="btn-group share-buttons pull-right hidden-xs">
                  <a href="#" target="_blank" class="btn">
                    <i class="fa fa-facebook"></i>
                  </a>
                  <a href="#" target="_blank" class="btn">
                    <i class="fa fa-twitter"></i>
                  </a>
                </div>

                <ul class="tags">
                  <li>
                    <a>Microsoft Azure</a>
                  </li>
                  <li>
                    <a>IoT</a>
                  </li>
                  <li>
                    <a>Microservices</a>
                  </li>
                  <li>
                    <a>Streaming Architecture</a>
                  </li>
                </ul>
              </div>

            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <footer>
    <div class="copyrights">&copy;
      <script type="text/javascript">
        document.write(new Date().getFullYear());
      </script> All rights reserved.
    </div>
  </footer>

  <script type="text/javascript" src="js/bootstrap.min.js"></script>
  <script type="text/javascript" src="js/pages-switcher.js"></script>
  <script type="text/javascript" src="js/imagesloaded.pkgd.min.js"></script>
  <script type="text/javascript" src="js/validator.js"></script>
  <script type="text/javascript" src="js/jquery.shuffle.min.js"></script>
  <script type="text/javascript" src="js/masonry.pkgd.min.js"></script>
  <script type="text/javascript" src="js/owl.carousel.min.js"></script>
  <script type="text/javascript" src="js/jquery.magnific-popup.min.js"></script>
  <script type="text/javascript" src="js/jquery.hoverdir.js"></script>
  <!--<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=YOUR-API-KEY"></script>-->
  <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js"></script>
  <script type="text/javascript" src="js/jquery.googlemap.js"></script>
  <script type="text/javascript" src="js/main.js"></script>
</body>

</html>